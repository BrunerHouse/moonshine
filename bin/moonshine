#!/usr/bin/env node

/**
 * @fileOverview Moonshine CLI binary.
 *
 * Format: moonshine command [option option ...] [filepattern filepattern ...]
 *
 * command can be one of:
 *	distil 			Distils a Lua script for use with Moonshine VM.
 *
 * options can be one or more of:
 * 	-j 				Use old JSON format to encode instructions in the output. 
 *					For use with older versions.
 * 	-m 				Minimise output. Strips out unnecessary debugging information. 
 *					Be aware that debugger will not work with this output.
 *	-o:filename 	Output filename. The distilled file will be named according to filename.
 *					Default = input_basename.lua.json
 *	-p:path 		Output path. The folder in which to place the output files.
 *					Default = current path
 *
 * filepattern can be:
 * 	filename 		Input filename. 
 * 	?				Use wildcards to specify patterns.
 * 	*				All files in current path.
 *
 * Examples:
 * 	moonshine distil -m -o:myoutput.json myinput.lua
 * 					Distils myinput.lua, removes debugging information and writes the
 *					output to myoutput.json
 *
 *	moonshine distil -j *
 * 					Distils all files in the current path using the old file format and
 *					default filenames.
 *
 *	moonshine distil -m mymod_v???.lua myothermod.lua 
 * 					Distils all files matching the pattern and myothermod.lua, strips
 *					out debugging and writes to the default filenames.
 * 
 *	moonshine distil -p:./json *
 * 					Distils all files to 'json' subfolder.
 * 
 * @author <a href="mailto:paul.cuthbertson@gamesys.co.uk">Paul Cuthbertson</a>
 * @copyright Gamesys Ltd 2013
 */




var command = process.argv[2],
	filenames = [],
	switches = {},
	Parser = require('../distillery/distillery.moonshine.js').Parser,
	exec = require('child_process').exec,
	fs = require('fs'),
	match,
	arg, i, l;


// Sort through arguments for switches and filenames
for (i = 3, l = process.argv.length; i < l; i++) {
	arg = process.argv[i];

	if (match = arg.match(/^(-\w+)(:(.*))?$/)) {
		switches[match[1]] = match[3] || true;
	} else {
		filenames.push(arg);
	}
}


// Execute command
switch (command) {
	case 'distil': return distil(filenames);
	default: return console.log('Unknown command: ' + command);
}




/**
 * Distil command. Distils a given list of file patterns.
 * @param {Array} filenames List of file patterns to distil.
 */
function distil (filenames) {
	var filename, i, l;

	for (i = 0, l = filenames.length; i < l; i++) {
		filename = filenames[i];
		if (/^.*\.lua$/.test(filename)) distilLua(filename);
	}
}




/**
 * Distils a Lua script. Compiles and distils the given filename.
 * @param {string} filename Input Lua filename.
 */
function distilLua (filename) {
	var luacFilename = filename + '.luac';

	exec('luac -o ' + luacFilename + ' ' + filename, function (err, stdout, stderr) {
		if (err) throw new Error(err);

		distilLuac(luacFilename, filename);
		fs.unlink(luacFilename);
	});
}




/**
 * Distils a Lua bytecode file.
 * @param {string} filename Bytecode filename.
 */
function distilLuac (luacFilename, luaFilename) {
	var pathLib = require('path'),
		parser = new Parser(),
		config = {
			stripDebugging: switches['-m'],
			useInstructionObjects: switches['-j']
		};

	parser.parse(luacFilename, config, function (tree) {
		var path = switches['-p'],
			reversePath = pathLib.relative(path, '.') + '/' + luaFilename,
			outputFilename = switches['-o'],
			filename;

		tree.sourcePath = reversePath;
		path = (!path || path === true)? './' : path + '/';

		if (outputFilename && outputFilename !== true) {
			filename = outputFilename;

		} else {
			//if (match = filename.match(/^(.*)\.luac$/)) filename = match[1];
			filename = luaFilename + '.json';
		}


		fs.writeFile(path + filename, JSON.stringify(tree), function (err) {
			if (err) throw new Error(err);
			console.log('File written: ' + path + filename);
		});
	});
}



